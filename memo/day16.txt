day16

1. 예외처리
	에러(Error)	: 개발자가 해결할 수 없는 문제(코드로 수습 불가)
	예외(Exception)	: 개발자가 해결 가능한 문제(코드로 수습 가능)

2) 예외의 발생 시점
	확인된 예외(checked exception, 일반예외) -> 컴파일러가 실시간 확인
		컴파일 단계에서 발생하는 예외(이클립스 빨간줄)

	미확인 예외( unchecked exception, 실행예외 Runtime Exception)
		프로그램 실행 중(런타임) 발생하는 예외
	
	자바의 모든 예외클래스는 Throwable을 상속받은 클래스로 만들어지고
	예외 클래스는 Exception 클래스를 상속받는다	
	실행예외는 RuntimeException과 해당 클래스를 상속받는 자식클래스이고
	그 밖의 예외는 모두 일반 예외이다
	
3) 예외처리
	예외가 발생했을때 프로그램이 비정상적으로 종료되는 것을 막고 정상적으로 실행될 수 있도록
	처리하는것을 의미한다 ex) 게임버그

	try{
		예외가 예상되는 코드
	 }catch(예외이름 객체명){
		예외를 처리하는 명령문
		(예외발생시 실행할 코드)
	 }eatch(예외이름 객체명){
		예외를 처리하는 명령문
		(예외발생시 실행할 코드)
	 }...
	 } finally{
		 예외발생 여부에 상관없이 무조건 실행할 코드
		// 생략가능
	 }
	 try 블록에서 작성한 코드가 예외없이 정상 실행되면 
	 catch븍록은 실행되지 않고 finally문이 실행된다
	
	catch는 위에서부터 검사하므로 위에서 예외가 잡히면 
	다른 catch문은 건너뛰고 finally문이 실행된다

4) 예외 클래스에서 제공하는 메소드
	자바에서는 발생할 수 있는 예외들을 클래스로 정의해두었다
	만약 실행중 오류가 발생하면 해당 오류클래스의 객체가 생성된다(메모리에 할당된다)
	예외처리를 해두었다면 그 객체의 주소를 catch(예외클래스 참조변수)의 참조변수가 받게된다
	예외클래스에는 다양한 기능을 제공한다
	
- .getMessage() : 예외 메시지를 문자열로 반환
- .toString()	: 발생한 예외 객체를 문자열로 반환
		 생략가능, 참조변수를 출력하면 자동으로 toString()가 사용된다
- .printStackTrace() : 예외가 발생지점을 추적하여 단계별로 전부 출력한다
	=> 예외처리를 적절하게 수행하면 프로그램의 안전성을 높이고, 신뢰성 있는 프로그램을 만들 수 있다


5) throws와 throw
	메소드 내부에서 예외가 발생할 떄 try-catch블록으로 예외를 처리하는 것이 기본이지만
	메소드를 호출하는 곳으로 예외처리를 떠넘길 수 있다

- throws : 예외 던지기, 메소드의 선언부에 사용한다
	메소드에서 발생할 수 있는 오류를 메소드를 정의할 때 처리하지 않고
	해당 메소드를 사용하는 쪽으로 던져서 메소드를 사용하는 개발자가 처리하도록 한다
	(상황에 맞게 예외처리하기 위함)
	ex) void method1() throws 예외클래스명 {}
	ex) void method2() throws 예외클래스명, 예외클래스명 {}

- throw : 예외를 발생시킨다(강제 예외 발생시키기)
	ex) throw new 예외명();

=> try{}catch(예외클래스명 참조변수){}
	참조변수.printStackTrace()
	참조변수.toString()
	참조변수.getMessage()
=> throws	예외 던지기, 메소드 선언부에 작성
=> throw	예외 강제로 발생시키기

6) 사용자 정의 예외
	사용자 정의 예외는 컴파일러가 체크하는 일반예외(excrption)로 선언할 수도 있고, 컴파일러가 체크하지 않는 실행예외(runtime)로 선언 할 수도 있다

	일반예외는 Exception 클래스를 상속받는 자식 클래스로 선언하고
	실행예외는 RuntimeException 클래스를 상속받는 자식 클래스로 선언한다
	
	기본 생성자와 예외메시지를 입력받는 생성자를 선언해주거나 super()에 예외메시지를 전달한다
	
	public class 예외클래스명+ extends Exceptiong or RuntimeException{
		생성자(){
			   super("사용자정의예외메시지");
      }

   }

2. API(Application Progreamming Interface)
	응용 프로그래밍 인터페이스 -> 하나의 번역기? 상호작용tool?
	
	내부 API
		-JDK(JRE, JVM) 설치 시 제공해주는 기본 api
		-자바로 어플리케이션을 쉽게 구현할 수 있도록 한 라이브러리 집합
	-https://docs.oracle.com/en/java/javase/17/docs/api/index.html			
	외부 API
		-다른 개발자들이 개발한 패키지 및 클래스들을 의미
		- 보통 jar 파일로 배포하며 자바 프로젝트에 build path에 추가하여 사용

1) API 공식문서 확인
	- 전체 상속관계를 보려면 상속 계층도를 보면 된다
	- api 도큐먼트에서 String 클래스가 어떻게 정의되어있는지는 아래쪽에 있는 선언부를 보면된다
	클래스가 final인지 추상클래스인지 알 수 있고, 부모클래스나 구현 인터페이스도 볼 수 있다
	- 구성멤버는 상단 메뉴에 SUMMARY를 보면된다
		멤버별 링크를 제공하는데 링크가 있으면 public, protected 공개된 멤버가 있다는 의미이고 링크가 없으면 공개된 멤버가 없다는 뜻이다. 

2) 모듈, 패키지, 라이브러리

- 모듈(module)
	자바 9부터 도입된 모듈 시스템
	코드를 논리적으로 그룹화하고 모듈간의 의존성을 관리하는 방법을 제공한다
	모듈은 패키지와 라이브러리의 개념을 확장하고 런타임에서 모듈의 논리적인 단위로 코드를 로드하고 관리할 수 있다. 
	코드의 의존성을 더욱 명확하게 정의하고 런타입 모듈 시스템을 통해 더 격리된 환경을 제공한다
	
- 패키지(Package)
	관련된 클래스 및 인터페이스를 그룹화 하는 방법을 제공한다
	패키지는 디렉토리 구조와 일치하고 패키지 내의 클래스들은 동일한 패키지 이름 공간안에 있어야한다
	코드를 구조화하고 이름 충돌을 방지하는데 도움을 준다
	
- 라이브러리(Library)
	jar(java Archive) 압축파일 형태로 존재한다. 
	jar 파일에는 클래스와 인터페이스의 바이트코드(.class)파일들이 압축/ 재사용 가능한 코드 집합
	특정 작업 또는 기능을 수행하기 위해 다른 프로그램에서 사용할 수 있게 해준다
	
3) 외부 API 
	JAR파일로 만든다
	Java Archive : Java 클래스파일, 리소스 파일 및 메타데이터를 포함하는 아카이브 파일
	
-Jar 파일 생성
	java 어플리케이션을 개발한 모든 파일들을 Jar파일ㄹ 패키징

-Jar 파일 배포
	Jar파일을 웹사이트, FTP 서버, 클라우드 저장소 등에 업로드하여 배포가능

-Jar 파일 실행
	jar파일을 실행하려면 Java Runtime Environment(JRE)가 필요하다
	java - jar [jar 파일명]

Jar 파일 배보
	배포할 프로젝트 마우스 우클릭 > Export > JAVA / JAR file 선택 > Next
	> Destination 원하는 경로로 선택 > Export Java Source files .. 체크(API 주석 포함) > Finish

외부 API Build Path에 추가
	배포된 jar 파일 다운로드 > 프로젝트 우클릭 > Build Path > Configure Build Path
	> Libraries 탭 클릭 > Add External JARs 클릭 > 저장된 경로의 .jar파일을 더블 클릭으로 추가 > Apply 클릭 > Orders and Exports 탭 클릭 > Selct All 클릭 > Apply and Close 클릭 


3. Stream API
	Java 8에서 도입된 기능
	함수형 프로그래밍을 지원하며 데이터의 흐름을 기반으로 하는 API
	컬렉션 데이터를 효과적으로 처리하고 조작하는데 사용된다
	데이터를 선언적으로 처리할 수 있다
	
+) 		선언적 언어		vs		명력적언어
		선언적- 명시함				명령적- 명시 안함
초점		무엇을 해야하는지			어떻게 해야하는지 정의
코드작성		간결하고 읽기 쉬움			절차적이고 복잡해질 수 있다
제어흐름		실행방법은 추상화			실행밥법을 상세히 기술
예시		Stream API, SQL, HTML, CSS	for, 조건문, ...


1) 스트림(Stream) - 일회성
	데이터의 흐름을 추상화한 것, 배열, 컬렉션, I/O 자원에서 데이터를 처리하기 위한 API
	데이터를 한 번만 소비, 기존 데이터 원본을 변경하지 않음
	=> 한 번만 소비한다는 것은 데이터를 처리한 뒤 재사용을 할 수 없다, 필요하면 새로운 스트림을 생성해야함
	(데이터를 순회하고 결과를 반환한 후에는 다시 사용할 수 없음을 의미하며 원본데이터를 절대 변경하지 않는다)
	=> 원본 데이터를 안전하게 유지한다	

2) 스트림 연산
- 중간연산 : 스트림을 변혼하는 작업, 결과가 또 다른 스트림으로 반환됨
	지연실행(Lazy Evaluation) : 최종연산이 호출 될 떄만 실행 -> 성능최적화
	연속적으로 연결가능(메소드 체이닝)
	filter(조건) : 조건에 맞는 요소만 남김
	map(함수) : 각 요소를 변환
	sorted : 요소를 정렬
	distinct() : 중복요소 제거
	limit(long) : 처음 n개 요소만 가져옴
	skip(long) : 처음 n개 요소를 건너뜀

- 최종연산 : 스트림을 처리하고 결과를 반환하거나 출력하는 작업
		스트림 파이프라인의 끝을 나타냄
		최종 연산 후 스트림은 더 이상 사용 불가능
	
	collect(Collector) : 스트림의 결과를 컬렉션 등으로 반환
	forEach(Consumer) : 각 요소를 소비 => forEach(System.out::println)- 메소드 참조
	count() : 요소의 개수를 반환
	reduce(BinaryOperator) : 스트림 요소를 누적 

+) 메소드 참조
	기존 메소드를 간결하게 호출하기 위한 표현식	
	ClassName::staticMethod
	ObjectName::insanceMethod
	ClassName::new(생성자참조)

3) 스트림 소스(Source)
	스트림을 생성하는 데이터 원본
	
	배열 : Arrays.stream(array)
	컬렉션 : List.stream(). Set.stream()
	숫자 범위 : IntStream.range(1,10)


4. Object클래스
	java.base모듈 
	-> java.lang패키지
	-> Object클래스 : 자바클래스 최상위 클래스 사용
	-> System : 키보드로부터 데이터를 입력받기 위해 사용, 모니터(콘솔)로 출력하기 위해 사용, 프로세스 종료시킬때 사용, 진생시간을 읽을 때 사용, 시스템 속성(프로퍼티)을 읽을 때 사용
	문자열 관련
	-> String : 문자열을 저장하고 조작할 떄 사용
	-> StringBuilder : 효율적인 문자열 조작기능이 필요할 때 사용
	포장관련
	-> Byte, Short : 기본 타입의 값을 포장할 때 사용
	-> Integer, Double : 문자열을 기본 타입으로 변환할 때 사용
	-> Math	: 수학 계산이 필요할 때 사용
	-> Class : 클래스의 메타정보(이름, 구성멤버) 등을 조사할 때 사용

1) Object 클래스
	모든 클래스의 최상위 부모 클래스

	boolean equlas(Object obj)	객체의 번지(주소값)를 비교하고 결과를 리턴
	int hashCode()			객체의 해시코드를 리턴
	String toString()		객체 문자 정보를 리턴
	
2) toString()
	Object의 toString()은 참조값을 문자열 형태로 출력한다
	참조변수를 print()등의 출력 메소드로 출력하면 항상 toString()이 사용된다 
	=> 참조값이 나온 이유
	toString()을 통해 출력되는 문자열을 바꾸고 싶다면 재정의해서 사용한다
	



























































	
	